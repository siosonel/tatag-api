exports.api = function (conf) {		
	var root = '/'; //may be overridden
	var	_id = conf._id ? conf._id : "@id";
	var	_type = conf._type ? conf._type : "@type";			
	var byId = {}, byType = {}, curr={};
	
	function main() {}
	
	function indexGraph(d) {
		if (d[_type]) curr[d[_type]] = d; //swap current resource by type

		if (d[_id]) {	
			//save typed resources in an array
			if (d[_type] && !byId[_id]) {
				if (!byType[d[_type]]) byType[d[_type]] = []
				byType[d[_type]] = d;
			}
			
			//index by self-url, will swap any existing values at the same url
			byId[d[_id]] = d; 
		}
	}
	
	main.init = function (url) {
		if (url) root = url;
		return main.loadId(root);
	}
		
	main.loadType = function (type) {		
		if (!byType[type]) {
			var url = byId[root][type];
			return main.loadId(url);
		}
		else {
			var deferred = Q.defer();
			deferred.resolve(byType[type]);
			return deferred.promise;
		}
	}	
	
	main.loadId = function (url, refresh) {
		var deferred = Q.defer();
		
		if (!url) deferred.reject(new Error('Blank url.'));
		else if (byId[url] && !refresh) {deferred.resolve(byId[url]); console.log("          (cache:"+url+")");}
		else request.get(url)
			.auth(conf.userid, conf.pass)
			.end(function (err, res) {
				if (err) deferred.reject(new Error(err));
				else if (!res || !res.body) deferred.reject(new Error('No response body.'));
				else {
					if (!res.body['@graph']) { //console.log('type '+type+' '+res.body[_type])
						res.body = {'@graph': [res.body]}; //coerce to graph layout
					}
										
					res.body['@graph'].map(indexGraph);
					deferred.resolve(res.body['@graph'][0]);
				}
			});
		
		return deferred.promise;
	}
	
	main.loadRel = function (resource, rel) {
		if (resource[rel]) return resource.rel;
		if (resource.links && resource.links[rel]) {
			var link = {}; 
			link[rel] = resource.links[rel];			
			return main.deref(link);
		}
	}
	
	main.deref = function (links, refresh) {
		var promises = [];
		if (!refresh) refresh=null;
		
		for(var rel in links) {
			if (typeof links[rel]=='string') promises.push(main.loadId(links[rel], refresh));
			else {				
				for(var i=0; i<links[rel].length; i++) {promises.push(main.loadId(links[rel][i], refresh));}
			}
		}
		
		return Q.all(promises);
	}
	
	main.request = function (action) {
		var deferred = Q.defer();
		action.method = action.method.toLowerCase();
		
		if (!action) deferred.resolve(null) 
		else {		
			request[action.method](action.target)
				.auth(conf.userid, conf.pass)
				.query(action.query)
				.send(action.inputs)
				.end(function (err, res) { 
					if (err) deferred.reject(new Error(err));
					else if (!res || !res.body) deferred.reject(new Error('No response body.'));
					else {
						if (!res.body['@graph']) res.body = {'@graph': [res.body]};									
						res.body['@graph'].map(indexGraph);
						deferred.resolve(res);
					}
				});
		}
				
		return deferred.promise;
	}	
	
	main.byId = byId
	main.byType = byType;	
	main.curr = curr
	
	return main;
}