exports.api = function (conf) {		
	var byId = {}, byType = {}, curr={};
	
	function main() {}
	
	function indexGraph(d) {
		if (d[conf._type]) curr[d[conf._type]] = d; //swap current representation

		if (d[conf._id]) {	
			//save typed resrouces in an array
			if (d[conf._type] && !byId[conf._id]) {
				if (!byType[d[conf._type]]) byType[d[conf._type]] = []
				byType[d[conf._type]] = d;
			}
			
			//index by self-url, will swap any existing values at the same url
			byId[d[conf._id]] = d; 
		}
	}
	
	main.load = function (type) {
		var deferred = Q.defer(), 
			url = type==conf.entrance._type
				? conf.entrance.value 
				: byType[conf.entrance._type][type];
		
		if (byType[type]) deferred.resolve(byType[type]); //use cached resource by type if available
		else if (!url) deferred.reject(new Error('No links for resource type:' +type+'.'));
		else request.get(url)
			.auth(conf.userid, conf.pass)
			.end(function (err, res) {
				if (err) deferred.reject(new Error(err));
				else if (!res || !res.body) deferred.reject(new Error('No response body.'));
				else {
					if (!res.body['@graph']) { //console.log('type '+type+' '+res.body[conf._type])
						if (!res.body[conf._type]) res.body[conf._type] = type; 
						res.body = {'@graph': [res.body]}; //coerce to graph layout
					}
										
					res.body['@graph'].map(indexGraph);
					deferred.resolve(byType[type]);
				}
			});
		
		return deferred.promise;
	}
	
	main.request = function (action) {
		var deferred = Q.defer();
		action.method = action.method.toLowerCase();
		
		if (!action) deferred.resolve(null) 
		else request[action.method](action.target)
			.auth(conf.userid, conf.pass)
			.query(action.query)
			.send(action.inputs)
			.end(function (err, res) { 
				if (err) deferred.reject(new Error(err));
				else if (!res || !res.body) deferred.reject(new Error('No response body.'));
				else {
					if (!res.body['@graph']) res.body = {'@graph': [res.body]};									
					res.body['@graph'].map(indexGraph);
					deferred.resolve(res);
				}
			});
				
		return deferred.promise;
	}
	
	main.byId = byId
	main.byType = byType;	
	main.curr = curr
	
	return main;
}